-- Some tests with Ethereum

local ETH = require('crypto_ethereum')
-- the transaction I want to encode is (e.g.)
-- | nonce     |                                          0 |
-- | gas price |                                          0 |
-- | gas limit |                                      25000 |
-- | to        | 0x627306090abaB3A6e1400e9345bC60c78a8BEf57 |
-- | value     |                                         11 |
-- | data      |                                            |
-- | chainId   |                                       1337 |

-- start Besu with the following command
-- besu --network=dev --miner-enabled --miner-coinbase=0xfe3b557e8fb62b89f4916b721be55ceb828dbd73 --rpc-http-cors-origins="all" --host-allowlist="*" --rpc-ws-enabled --rpc-http-enabled --data-path=/tmp/tmpDatdir

-- 0 is encoded as the empty octet (O.new())

tx = {}
tx["nonce"] = ETH.o2n(O.new())
tx["gasPrice"] = INT.new(1000)
tx["gasLimit"] = INT.new(25000) 
tx["to"] = O.from_hex('627306090abaB3A6e1400e9345bC60c78a8BEf57')
tx["value"] = INT.new(O.from_hex('11'))
tx["data"] = O.new()
-- v contains the chain id (when the transaction is not signed)
-- We always use the chain id
tx["v"] = INT.new(1337)
tx["r"] = O.new()
tx["s"] = O.new()

from = O.from_hex('ae6ae8e5ccbfb04590405997ee2d52d2b330726137b875053c36d94e974d162f')
pk = ECDH.pubgen(from)


encodedTx = ETH.encodeSignedTransaction(from, tx)

print(encodedTx:hex())
decodedTx = ETH.decodeTransaction(encodedTx)

fields = {"nonce", "gasPrice", "gasLimit", "to",
	  "value", "data"}
for _, v in pairs(fields) do
   assert(tx[v] == decodedTx[v])
end

assert(ETH.verifySignatureTransaction(pk, tx))
assert(ETH.verifySignatureTransaction(pk, decodedTx))

assert(ETH.makeWriteStringData('ciao mondo') == O.from_hex('dd2062020000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000a6369616f206d6f6e646f00000000000000000000000000000000000000000000'))
assert(ETH.makeWriteStringData('aaaabbbbccccddddaaaabbbbccccddddaaaabbbbccccddddaaaabbbbccccddddaaaabbbbccccddddaaaabbbbccccddddaaaabbbbccccddddaaaabbbbccccddddaaaabbbbccccddddaaaabbbbccccddddaaaabbbbccccddddaaaabbbbccccddddaaaabbbbccccddddaaaabbbbccccddddaaaabbbbccccddddaaaabbbbccccddddaaaabbbbccccddddaaaabbbbccccddddaaaabbbbccccddddaaaabbbbccccddddaaaabbbbccccddddaaaabbbbccccddddaaaabbbbccccddddaaaabbbbccccddddaaaabbbbccccddddaaaabbbbccccddddaaaabbbbccccddddaaaabbbbccccddddaaaabbbbccccddddaaaabbbbccccddddaaaabbbbccccddddaaaabbbbccccddddpadding') == O.from_hex('dd20620200000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000207616161616262626263636363646464646161616162626262636363636464646461616161626262626363636364646464616161616262626263636363646464646161616162626262636363636464646461616161626262626363636364646464616161616262626263636363646464646161616162626262636363636464646461616161626262626363636364646464616161616262626263636363646464646161616162626262636363636464646461616161626262626363636364646464616161616262626263636363646464646161616162626262636363636464646461616161626262626363636364646464616161616262626263636363646464646161616162626262636363636464646461616161626262626363636364646464616161616262626263636363646464646161616162626262636363636464646461616161626262626363636364646464616161616262626263636363646464646161616162626262636363636464646461616161626262626363636364646464616161616262626263636363646464646161616162626262636363636464646461616161626262626363636364646464616161616262626263636363646464646161616162626262636363636464646461616161626262626363636364646464616161616262626263636363646464646161616162626262636363636464646470616464696e6700000000000000000000000000000000000000000000000000'))


-- The following transaction depends on the address of the smart contract
-- tx = {
--    nonce=O.new(),
--    to=O.from_hex('F12b5dd4EAD5F743C6BaA640B0216200e89B60Da'),
--    value=O.new(),
--    data=makeWriteStringData('generated by script'),
--    gasPrice=O.from_hex('03e8'),
--    -- --gasLimit=INT.new('3000000'),
--    gasLimit=O.from_hex('2dc6c0'),
--    v=INT.new(1337),
--    r=O.new(),
--    s=O.new()
-- }

-- encodedTx = encodeSignedTransaction(from, tx)
-- print(encodedTx:hex())

print("New key pair")
kp = ETH.keygen()
print(kp.address:hex())
print(kp.private:hex())


-- -- Send some eth to the new address
-- tx = {
--    nonce=O.from_hex('01'),
--    to=kp.address,
--    value=O.from_hex('100000'),
--    data=O.new(),
--    gasPrice=O.from_hex('03e8'),
--    -- --gasLimit=INT.new('3000000'),
--    gasLimit=O.from_hex('2dc6c0'),
--    v=INT.new(1337),
--    r=O.new(),
--    s=O.new()
-- }

-- encodedTx = encodeSignedTransaction(from, tx)
-- print("Send some eth to the new address")
-- print(encodedTx:hex())


-- Some test with data generation for smart conctract
-- function baz(uint32 x, bool y)
local contract = ETH.data_contract_builder('baz', { 'uint32', 'bool' })
assert(contract(69, true) == O.from_hex('cdcd77c000000000000000000000000000000000000000000000000000000000000000450000000000000000000000000000000000000000000000000000000000000001'))


print("ERC 20")
assert(ETH.erc20.balanceOf(O.from_hex('19e942FB3193bb2a3D6bAD206ECBe9E60599c388')) == O.from_hex('70a0823100000000000000000000000019e942fb3193bb2a3d6bad206ecbe9e60599c388'))
assert(ETH.erc20.transfer(O.from_hex('e24Cd6B528A513181C765d3dadb0809E1eF991f5'), BIG.from_decimal('1000')) == O.from_hex('a9059cbb000000000000000000000000e24cd6b528a513181c765d3dadb0809e1ef991f500000000000000000000000000000000000000000000000000000000000003e8'))
assert(ETH.erc20.decimals() == O.from_hex('313ce567'))
assert(ETH.erc20.symbol() == O.from_hex('95d89b41'))
assert(ETH.erc20.totalSupply() == O.from_hex('18160ddd'))
assert(ETH.erc20.approve(O.from_hex('19e942FB3193bb2a3D6bAD206ECBe9E60599c388'), 1000) == O.from_hex('095ea7b300000000000000000000000019e942fb3193bb2a3d6bad206ecbe9e60599c38800000000000000000000000000000000000000000000000000000000000003e8'))
assert(ETH.erc20.transferFrom(O.from_hex('19e942FB3193bb2a3D6bAD206ECBe9E60599c388'), O.from_hex('e24Cd6B528A513181C765d3dadb0809E1eF991f5'), 1000) == O.from_hex('23b872dd00000000000000000000000019e942fb3193bb2a3d6bad206ecbe9e60599c388000000000000000000000000e24cd6b528a513181c765d3dadb0809e1ef991f500000000000000000000000000000000000000000000000000000000000003e8'))


-- tx = {}
-- tx["nonce"] = ETH.o2n(O.new())
-- tx["gasPrice"] = INT.new(1000)
-- tx["gasLimit"] = INT.new(25000)
-- tx["to"] = O.from_hex('627306090abaB3A6e1400e9345bC60c78a8BEf57')
-- tx["value"] = INT.new(O.from_hex('11'))
-- tx["data"] = O.new()
-- -- v contains the chain id (when the transaction is not signed)
-- -- We always use the chain id
-- tx["v"] = INT.new(1337)
-- tx["r"] = O.new()
-- tx["s"] = O.new()

-- from = O.from_hex('ae6ae8e5ccbfb04590405997ee2d52d2b330726137b875053c36d94e974d162f')
-- pk = ECDH.pubgen(from)


-- encodedTx = ETH.encodeSignedTransaction(from, tx)

-- print(encodedTx:hex())
-- decodedTx = ETH.decodeTransaction(encodedTx)
